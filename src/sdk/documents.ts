/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { documentsCreateV0 } from "../funcs/documentsCreateV0.js";
import { documentsDelete } from "../funcs/documentsDelete.js";
import { documentsDistribute } from "../funcs/documentsDistribute.js";
import { documentsDuplicate } from "../funcs/documentsDuplicate.js";
import { documentsFind } from "../funcs/documentsFind.js";
import { documentsGet } from "../funcs/documentsGet.js";
import { documentsRedistribute } from "../funcs/documentsRedistribute.js";
import { documentsUpdate } from "../funcs/documentsUpdate.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { DocumentsFields } from "./documentsfields.js";
import { DocumentsRecipients } from "./documentsrecipients.js";

export class Documents extends ClientSDK {
  private _fields?: DocumentsFields;
  get fields(): DocumentsFields {
    return (this._fields ??= new DocumentsFields(this._options));
  }

  private _recipients?: DocumentsRecipients;
  get recipients(): DocumentsRecipients {
    return (this._recipients ??= new DocumentsRecipients(this._options));
  }

  /**
   * Get document
   *
   * @remarks
   * Returns a document given an ID
   */
  async get(
    request: operations.DocumentGetRequest,
    options?: RequestOptions,
  ): Promise<operations.DocumentGetResponse> {
    return unwrapAsync(documentsGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Find documents
   *
   * @remarks
   * Find documents based on a search criteria
   */
  async find(
    request: operations.DocumentFindRequest,
    options?: RequestOptions,
  ): Promise<operations.DocumentFindResponse> {
    return unwrapAsync(documentsFind(
      this,
      request,
      options,
    ));
  }

  /**
   * Update document
   */
  async update(
    request: operations.DocumentUpdateRequest,
    options?: RequestOptions,
  ): Promise<operations.DocumentUpdateResponse> {
    return unwrapAsync(documentsUpdate(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete document
   */
  async delete(
    request: operations.DocumentDeleteRequest,
    options?: RequestOptions,
  ): Promise<operations.DocumentDeleteResponse> {
    return unwrapAsync(documentsDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Duplicate document
   */
  async duplicate(
    request: operations.DocumentDuplicateRequest,
    options?: RequestOptions,
  ): Promise<operations.DocumentDuplicateResponse> {
    return unwrapAsync(documentsDuplicate(
      this,
      request,
      options,
    ));
  }

  /**
   * Distribute document
   *
   * @remarks
   * Send the document out to recipients based on your distribution method
   */
  async distribute(
    request: operations.DocumentDistributeRequest,
    options?: RequestOptions,
  ): Promise<operations.DocumentDistributeResponse> {
    return unwrapAsync(documentsDistribute(
      this,
      request,
      options,
    ));
  }

  /**
   * Redistribute document
   *
   * @remarks
   * Redistribute the document to the provided recipients who have not actioned the document. Will use the distribution method set in the document
   */
  async redistribute(
    request: operations.DocumentRedistributeRequest,
    options?: RequestOptions,
  ): Promise<operations.DocumentRedistributeResponse> {
    return unwrapAsync(documentsRedistribute(
      this,
      request,
      options,
    ));
  }

  /**
   * Create document
   *
   * @remarks
   * You will need to upload the PDF to the provided URL returned. Note: Once V2 API is released, this will be removed since we will allow direct uploads, instead of using an upload URL.
   */
  async createV0(
    request: operations.DocumentCreateDocumentTemporaryRequest,
    options?: RequestOptions,
  ): Promise<operations.DocumentCreateDocumentTemporaryResponse> {
    return unwrapAsync(documentsCreateV0(
      this,
      request,
      options,
    ));
  }
}
